;;; slf-open-file-under-cursor.el --- Open the file under the cursor.

;; Copyright (C) 2015 Steve Flenniken
;; Author: Steve Flenniken <steve.flenniken@gmail.com>
;; URL: http://github.com/flenniken/slf-open-file-under-cursor
;; Version: 0.1
;; Package-Version: 20150525.1105

;;; Commentary:

;; Open the file under the cursor and go to the specified line number.

;; The command parses the current line to extract the filename and
;; line number. Then it opens the file and goes to the line.

;; The command supports four common file/line formats generated by
;; grep, a couple stack traces and logging.

;; Line formats:

;; 1.  filename:10:...
;; 2.  ... in filename line 20...
;; 3.  ...File \"filename\" line 30...
;; 4.  ...:basename(40):...
;; 5.  YYYY-MM-DD HH:MM:SS num basename(40) ...


;; Filename is either a full path or a filename relative to the
;; current directory.

;; The fourth and fifth version, \":basename(40)\", supports filenames
;; without path information. The basename is searched in the base
;; folder and its subfolders to find the file. It uses the system find
;; command to search the folder.  For the base folder use the git root
;; folder relative to the current file if it exists, else use the last
;; base folder found or when no last folder, prompt for it.

;; You can add support for other formats by adding a regular
;; expression and a few lines of code.

(defvar slf-base-folder nil "The default base folder for matcher 4. Used when the folder cannot be found automatically.")

(defun slf-open-file-under-cursor()
"Open the file under the cursor and go to the specified line number.

The command parses the current line to extract the filename and
line number. Then it opens the file and goes to the line.
"
  (interactive)
  (let (filename line result)

    ;; Get the filename and line under the cursor.
    (setq result (slf-file-under-cursor))

    (when (not result)
      (error "No filename found under the cursor."))
    (setq filename (car result))
    (setq line (nth 1 result))

    (when (not (file-exists-p filename))
      (error "File not found: %s(%s)" filename line))

    ; Open the file and go to the line.
    (message "%s(%s)" filename line)
    (find-file filename)
    (when line
      (goto-char (point-min))
      (forward-line (1- (string-to-number line))))))


(defun slf-file-under-cursor()
" Return the file and line number under the cursor.

Return a list with the filename and line, or nil when not found.
"
  ;; If there is a selection, use that as the filename (no line).
  (let (result string)
    (if mark-active
      (setq result (list (buffer-substring-no-properties (mark) (point)) nil))
      (save-excursion
        ;; Get the current line as a string.
        (let (end)
          (end-of-line)
          (setq end (point))
          (beginning-of-line)
          (setq string (buffer-substring-no-properties (point) end)))
        ;; (message "string = %s" string)

        ;; Loop though the line patterns. Stop when the first one
        ;; returns a filename.
        (let (functions fun)
          (setq functions (list 'slf-match1 'slf-match2 'slf-match3 'slf_path_match))
          (setq result nil)
          (while (and (not result) functions)
              (setq fun (car functions))
              (setq result (funcall fun string))
              (when result
                (message "matching fun = %s" fun))
              (setq functions (cdr functions))))))
    result))


(defun slf-matcher(pattern string)
"Parse the given string and return a list containing a filename and line number.
"
  (if (string-match pattern string)
    (list (match-string 1 string) (match-string 2 string))
    nil))


(defun slf-match1(string)
"
./Macintosh/Mac_Terminal.txt:6:Created Friday 20 January 2012
filename:71:...
2015-12-04 12:33:45 README.md(7) testing
"
  (slf-matcher "^\\([^ ]*\\):\\([0-9]*\\):" string))


(defun slf-match2(string)
"
...File \"filename\"...line 123 ...
"
  (slf-matcher "File \"\\(.*\\)\".*line \\([0-9]*\\)" string))


(defun slf-match3(string)
"
0.5:hd58: called from item_form_cgi in /inet/var_local/git-sandboxes/dev-sflennik1/python/printra/sossite/ItemFormCGI.py line 106
"
  (slf-matcher " in \\(.*\\) line \\([0-9]*\\)" string))

(defun slf-match4(string)
  (slf-matcher ":\\([^:]*\\)(\\([0-9]*\\)):" string))

; 2015-11-12 21:53:21 1234 test.txt(30) first line
(defun slf-match5(string)
  (slf-matcher "....-..-.. ..:..:.. [0-9]+ \\([^ ]*\\)(\\([0-9]*\\)) " string))

(defun slf_path_match(string &optional folder)
"This match method finds a basename in the given string then it
looks for the basename in the given folder. It returns a list
with the full path to the file and the line number, or nil when
not found.

Examples:
...:basename(linenum):...
3.4:mh42:gadgets.py(147): template file: tmpls/header
asafd:emacs(22): test line
"
  (interactive "sstring: \nDfolder: ")
  (let (result ret)
    (setq result (slf-match4 string))
    (when (not result)
      (setq result (slf-match5 string)))
    ;; (message "result = %s" result)
    (setq ret nil)
    (when result
      ;; When the folder is not specified, look or prompt for it.
      (when (or (not folder) (equal folder ""))
        (setq folder (slf-find-base-folder))
        ;; (message "root folder = %s" folder)
      )
      (when folder
        ;; Make sure the specifed folder exists.
        (when (or (not (file-exists-p folder)) (equal folder ""))
          (error (format "'%s' folder does not exist." folder)))
        ;; Look for the basename in the root folder.
        (setq path (slf-find-basename folder (car result)))
        (if path
          (setq ret (list path (nth 1 result)))
          (setq ret nil))))
    (when (version<= "24" emacs-version)
      (when (called-interactively-p 'interactive)
        (message "ret=%s" ret)))
    ret))


(defun slf-find-basename(folder basename)
"Find the given basename in the given folder and return the
location of the file if found, or nil when not found.

This uses the system find command.
"
  (interactive "Dfolder: \nsbasename: ")
  (let (command result path)
    ;; Run the find command and get the first file found.
    ;; (setq command (concat "find -L " folder " -name " basename  " 2>/dev/null"))
    (setq command (concat "find -L " folder " -name " basename))
    (setq result (shell-command-to-string command))
    ;; (message "command = '%s'" command)
    ;; (message "result = '%s'" result)
    (setq path (nth 0 (split-string result "\n" t)))
    (when (version<= "24" emacs-version)
      (when (called-interactively-p 'interactive)
        (message "path='%s'" path)))
    path))


(defun slf-find-base-folder()
"Return the base folder to search for files.
Use the git root folder relative to the current file if it
exists, else use the last base folder found or when no last
folder, prompt for it.
"
  (interactive)
  (let (git-root)
    ;; Look for the git root folder relative to the current file.
    (setq git-root (slf-look-for-git (buffer-file-name)))
    ;; When the git root folder cannot be found, use the last one
    ;; found.
    (when (not git-root)
      (setq git-root slf-base-folder))
    ;; If no last one, prompt for it.
    (when (not git-root)
      (setq git-root (read-from-minibuffer "base folder: " nil nil nil nil default-directory))
      (when (equal (length git-root) 0)
        (error ""))
      ;; Add an ending slash if needed.
      (when (not (equal (substring git-root -1) "/"))
        (setq git-root (concat git-root "/"))
        )
      ;; Make sure the entered directory exists.
      (when (not (file-exists-p git-root))
        (error (format "'%s' is not a directory." git-root))))

    (setq slf-base-folder git-root)
    (when (version<= "24" emacs-version)
      (when (called-interactively-p 'interactive)
        (message "slf-base-folder='%s'" slf-base-folder)))
    slf-base-folder))

;; (setq slf-base-folder nil)

(defun slf-folder-part(path)
" Return the folder of the given path.
"
  ;; /home/steve/code/file.py ->
  ;; /home/steve/code/ ->
  ;; /home/steve/ ->
  ;; /home/ ->
  ;; / ->
  ;; nil
  (if (equal (substring path -1) "/")
    (file-name-directory (substring path 0 -1))
    (file-name-directory path)))


(defun slf-look-for-git(filename)
"Look for the .git folder relative to the given filename.

Return the folder or nil when not found.
"
  (interactive "fpath:")
  (let (root folder name)
    (setq root nil)
    (setq name filename)
    (when name
      (setq folder (slf-folder-part name))
      (while folder
        (if (file-exists-p (concat folder ".git"))
          (progn
            (setq root folder)
            (setq folder nil))
          (setq folder (slf-folder-part folder))))
      (when (version<= "24" emacs-version)
        (when (called-interactively-p 'interactive)
          (message "git folder = '%s'" root)))
      root)))

;;; slf-open-file-under-cursor.el ends here
